import pygame
import RPi.GPIO as GPIO
import time
import sys
import subprocess
import threading
import io
from PIL import Image

# GPIO Setup
IN1, IN2 = 17, 18
IN3, IN4 = 22, 23
ENA, ENB = 27, 24

GPIO.setmode(GPIO.BCM)
GPIO.setup([IN1, IN2, IN3, IN4, ENA, ENB], GPIO.OUT)

pwm_ENA = GPIO.PWM(ENA, 1000)
pwm_ENB = GPIO.PWM(ENB, 1000)
pwm_ENA.start(0)
pwm_ENB.start(0)

def move_forward():
    GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.HIGH)
    pwm_ENA.ChangeDutyCycle(100)
    pwm_ENB.ChangeDutyCycle(100)

def move_backward():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN3, GPIO.HIGH)
    GPIO.output(IN4, GPIO.LOW)
    pwm_ENA.ChangeDutyCycle(100)
    pwm_ENB.ChangeDutyCycle(100)

def turn_left():
    GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.LOW)
    pwm_ENA.ChangeDutyCycle(100)
    pwm_ENB.ChangeDutyCycle(100)

def turn_right():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.HIGH)
    pwm_ENA.ChangeDutyCycle(100)
    pwm_ENB.ChangeDutyCycle(100)

def stop_motors():
    GPIO.output([IN1, IN2, IN3, IN4], GPIO.LOW)
    pwm_ENA.ChangeDutyCycle(0)
    pwm_ENB.ChangeDutyCycle(0)

# Pygame UI Setup
pygame.init()
screen_width, screen_height = 1024, 600
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption("Robot Touch Controller")

WHITE = (255, 255, 255)
BLUE = (50, 120, 255)
BG = (240, 240, 240)
GRAY = (100, 100, 100)

camera_height = 300

# Button hitboxes
forward_rect = pygame.Rect(412, 320, 200, 100)
backward_rect = pygame.Rect(412, 460, 200, 100)
left_rect = pygame.Rect(100, 380, 200, 120)
right_rect = pygame.Rect(724, 380, 200, 120)
camera_button_rect = pygame.Rect(screen_width - 160, screen_height - 50, 140, 40)

def draw_arrow(surface, points, color):
    pygame.draw.polygon(surface, color, points)

frame_surface = None
camera_enabled = True
running = True
current_status = "Idle"
font = pygame.font.Font(None, 28)

def camera_loop():
    global frame_surface
    while running:
        if not camera_enabled:
            time.sleep(0.1)
            continue

        cmd = [
            'libcamera-vid', '-n', '-t', '0', '--inline', '--codec', 'mjpeg',
            '--width', str(screen_width), '--height', str(camera_height), '-o', '-'
        ]
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, bufsize=0)
        buffer = b''

        try:
            while running and camera_enabled:
                chunk = proc.stdout.read(4096)
                if not chunk:
                    break
                buffer += chunk
                start = buffer.find(b'\xff\xd8')
                end = buffer.find(b'\xff\xd9')
                if start != -1 and end > start:
                    jpg = buffer[start:end+2]
                    buffer = buffer[end+2:]
                    try:
                        img = Image.open(io.BytesIO(jpg)).transpose(Image.ROTATE_180).convert("RGB")
                        img = img.resize((screen_width, camera_height))
                        frame_surface = pygame.image.fromstring(img.tobytes(), img.size, img.mode)
                    except Exception:
                        continue
        finally:
            proc.terminate()

camera_thread = threading.Thread(target=camera_loop, daemon=True)
camera_thread.start()

last_touch_time = time.time()
timeout = 1.0

try:
    while running:
        screen.fill(BG)

        # Display camera feed
        if camera_enabled and frame_surface:
            screen.blit(frame_surface, (0, 0))

        # Draw arrows
        draw_arrow(screen, [(512, 330), (472, 400), (552, 400)], BLUE)  # Forward
        draw_arrow(screen, [(512, 550), (472, 480), (552, 480)], BLUE)  # Backward
        draw_arrow(screen, [(200, 440), (280, 410), (280, 470)], BLUE)  # Left
        draw_arrow(screen, [(824, 440), (744, 410), (744, 470)], BLUE)  # Right

        # Draw status text (bottom-left)
        status_surface = font.render(f"Status: {current_status}", True, (0, 0, 0))
        screen.blit(status_surface, (20, screen_height - 30))

        # Draw camera toggle button (bottom-right)
        pygame.draw.rect(screen, GRAY, camera_button_rect, border_radius=8)
        cam_text = font.render("Camera Off" if camera_enabled else "Camera On", True, WHITE)
        screen.blit(cam_text, (camera_button_rect.x + 10, camera_button_rect.y + 10))

        pygame.display.flip()
        touched = False

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type in (pygame.MOUSEBUTTONDOWN, pygame.FINGERDOWN):
                x, y = (event.x * screen_width, event.y * screen_height) if event.type == pygame.FINGERDOWN else event.pos

                if forward_rect.collidepoint(x, y):
                    move_forward()
                    current_status = "Moving Forward"
                elif backward_rect.collidepoint(x, y):
                    move_backward()
                    current_status = "Moving Backward"
                elif left_rect.collidepoint(x, y):
                    turn_left()
                    current_status = "Turning Left"
                elif right_rect.collidepoint(x, y):
                    turn_right()
                    current_status = "Turning Right"
                elif camera_button_rect.collidepoint(x, y):
                    camera_enabled = not camera_enabled
                    current_status = "Camera Off" if not camera_enabled else "Camera On"
                    frame_surface = None

                last_touch_time = time.time()
                touched = True

        if not touched and (time.time() - last_touch_time > timeout):
            stop_motors()
            current_status = "Idle"

        time.sleep(0.05)

finally:
    stop_motors()
    GPIO.cleanup()
    pygame.quit()
    sys.exit()
